"""
Cache Manager for Recipe Keeper
Manages recipe cache with Redis primary + in-memory fallback
"""

import asyncio
import json
from typing import Optional, Dict, Any
from datetime import datetime

try:
    import redis.asyncio as redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    print("Warning: redis package not installed, using memory cache only")

from cachetools import TTLCache

from config import config
from models import Recipe


class CacheManager:
    """Manage recipe cache with Redis primary + in-memory fallback"""

    def __init__(self):
        """Initialize cache manager"""
        # Redis (primary)
        self.redis_client: Optional[redis.Redis] = None
        self.redis_available = False
        self.redis_init_attempted = False

        # In-memory fallback
        self.memory_cache = TTLCache(
            maxsize=config.CACHE_MAX_ITEMS,  # Default: 1000
            ttl=config.CACHE_TTL_SECONDS      # Default: 24h
        )

        # Thread safety
        self.lock = None  # Will be created when event loop is available

        # Statistics
        self.stats = {
            "redis_hits": 0,
            "memory_hits": 0,
            "misses": 0,
            "redis_errors": 0,
        }

        # Don't initialize Redis here - will be done lazily on first use
        if not REDIS_AVAILABLE or not config.REDIS_URL:
            print("Redis not configured or package not installed, using memory cache only")

    async def _ensure_initialized(self):
        """Ensure async components are initialized (lock and Redis)"""
        # Initialize lock if needed
        if self.lock is None:
            self.lock = asyncio.Lock()

        # Initialize Redis connection if not attempted yet
        if not self.redis_init_attempted and REDIS_AVAILABLE and config.REDIS_URL:
            self.redis_init_attempted = True
            await self._init_redis()

    async def _init_redis(self):
        """Initialize Redis connection"""
        if not config.REDIS_URL:
            print("Redis URL not configured, using memory cache only")
            return

        if not REDIS_AVAILABLE:
            print("Redis package not installed, using memory cache only")
            return

        try:
            self.redis_client = redis.from_url(
                config.REDIS_URL,
                encoding="utf-8",
                decode_responses=True,
                socket_connect_timeout=5,
                socket_timeout=5
            )
            # Test connection
            await self.redis_client.ping()
            self.redis_available = True
            print("✓ Redis connection successful")
        except Exception as e:
            print(f"✗ Redis connection failed: {e}")
            print("Falling back to in-memory cache only")
            self.redis_available = False

    async def get(self, cache_key: str) -> Optional[Recipe]:
        """
        Get recipe from cache (try Redis first, then memory)

        Args:
            cache_key: Cache key generated by url_normalizer

        Returns:
            Recipe object if found, None otherwise
        """
        await self._ensure_initialized()
        async with self.lock:
            # Try Redis first
            if self.redis_available:
                try:
                    recipe_json = await self.redis_client.get(f"recipe:{cache_key}")
                    if recipe_json:
                        self.stats["redis_hits"] += 1
                        print(f"✓ Cache HIT (Redis): {cache_key}")
                        recipe_dict = json.loads(recipe_json)
                        recipe = Recipe(**recipe_dict)
                        # Warm memory cache
                        self.memory_cache[cache_key] = recipe
                        return recipe
                except Exception as e:
                    print(f"✗ Redis get error: {e}")
                    self.stats["redis_errors"] += 1
                    self.redis_available = False

            # Fallback to memory cache
            if cache_key in self.memory_cache:
                self.stats["memory_hits"] += 1
                print(f"✓ Cache HIT (Memory): {cache_key}")
                return self.memory_cache[cache_key]

            # Cache miss
            self.stats["misses"] += 1
            print(f"○ Cache MISS: {cache_key}")
            return None

    async def set(
        self,
        cache_key: str,
        recipe: Recipe,
        canonical_url: str,
        platform: str
    ):
        """
        Store recipe in cache (both Redis and memory)

        Args:
            cache_key: Cache key generated by url_normalizer
            recipe: Recipe object to cache
            canonical_url: Normalized URL (for logging)
            platform: Platform name (for logging)
        """
        await self._ensure_initialized()
        async with self.lock:
            # Store in memory (always)
            self.memory_cache[cache_key] = recipe

            # Store in Redis (if available)
            if self.redis_available:
                try:
                    recipe_json = recipe.model_dump_json()
                    await self.redis_client.setex(
                        f"recipe:{cache_key}",
                        config.CACHE_TTL_SECONDS,  # 24h TTL
                        recipe_json
                    )
                    print(f"✓ Cached recipe (Redis + Memory): {cache_key} [{platform}]")
                except Exception as e:
                    print(f"✗ Redis set error: {e}")
                    self.stats["redis_errors"] += 1
                    self.redis_available = False
                    print(f"✓ Cached recipe (Memory only): {cache_key} [{platform}]")
            else:
                print(f"✓ Cached recipe (Memory only): {cache_key} [{platform}]")

    async def delete(self, cache_key: str):
        """
        Delete specific cache entry

        Args:
            cache_key: Cache key to delete
        """
        await self._ensure_initialized()
        async with self.lock:
            # Delete from memory
            if cache_key in self.memory_cache:
                del self.memory_cache[cache_key]

            # Delete from Redis
            if self.redis_available:
                try:
                    await self.redis_client.delete(f"recipe:{cache_key}")
                except Exception as e:
                    print(f"✗ Redis delete error: {e}")

            print(f"✓ Deleted cache entry: {cache_key}")

    async def clear(self):
        """Clear entire cache"""
        await self._ensure_initialized()
        async with self.lock:
            # Clear memory
            self.memory_cache.clear()

            # Clear Redis
            if self.redis_available:
                try:
                    # Delete all recipe:* keys
                    pattern = "recipe:*"
                    cursor = 0
                    deleted_count = 0
                    while True:
                        cursor, keys = await self.redis_client.scan(
                            cursor, match=pattern, count=100
                        )
                        if keys:
                            await self.redis_client.delete(*keys)
                            deleted_count += len(keys)
                        if cursor == 0:
                            break
                    print(f"✓ Cleared {deleted_count} Redis entries")
                except Exception as e:
                    print(f"✗ Redis clear error: {e}")

            # Reset stats
            self.stats = {
                "redis_hits": 0,
                "memory_hits": 0,
                "misses": 0,
                "redis_errors": 0,
            }
            print("✓ Cache cleared")

    async def get_stats(self) -> Dict[str, Any]:
        """
        Get cache statistics

        Returns:
            Dictionary with cache statistics
        """
        await self._ensure_initialized()
        async with self.lock:
            total = (
                self.stats["redis_hits"] +
                self.stats["memory_hits"] +
                self.stats["misses"]
            )
            hit_rate = (
                (self.stats["redis_hits"] + self.stats["memory_hits"]) / total
                if total > 0 else 0.0
            )

            redis_size = 0
            if self.redis_available:
                try:
                    redis_size = await self.redis_client.dbsize()
                except:
                    redis_size = -1  # Error indicator

            return {
                "redis_available": self.redis_available,
                "redis_size": redis_size,
                "memory_size": len(self.memory_cache),
                "redis_hits": self.stats["redis_hits"],
                "memory_hits": self.stats["memory_hits"],
                "misses": self.stats["misses"],
                "hit_rate": hit_rate,
                "redis_errors": self.stats["redis_errors"],
            }

    async def health_check(self) -> Dict[str, Any]:
        """
        Check Redis connection health

        Returns:
            Dictionary with health status
        """
        await self._ensure_initialized()

        if not self.redis_available and REDIS_AVAILABLE and config.REDIS_URL:
            # Try to reconnect
            await self._init_redis()

        return {
            "redis_available": self.redis_available,
            "memory_cache_size": len(self.memory_cache),
            "redis_configured": config.REDIS_URL is not None,
            "redis_package_installed": REDIS_AVAILABLE,
        }


# Singleton instance
cache_manager = CacheManager()
